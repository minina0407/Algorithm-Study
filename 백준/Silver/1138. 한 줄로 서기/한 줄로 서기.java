
import java.io.IOException;
import java.util.*;


public class Main {

    public static void main(String[] args) throws IOException {
        /*
        자기보다 큰 사람이 왼쪽에 몇명 있는지만 기억
        N명의 사람이 있고, 사람들의 키는 1부터 N까지 모두 다르다.
        그러면 수열에서 내 idx까지의 최댓값을 찾는다.
        입력 : N - 사람의 수, N은 10보다 작거나 같은 자연수
        다음 줄에는 키가 1인 사람부터 차례대로 자기보다 키가 큰 사람이
        왼쪽에 몇명있는지 주어진다. -> 현재 idx보다 큰 값들의 갯수 출력됨
        i번쨰수는 0보다 크거나 같고 N-i보다 작거나 같다.
        i는 0부터 시작한다.
        출력 : 줄을 선 순서대로 키를 출력한다.
        키가 1인사람은 자기보다 큰사람이 왼쪾에 두명 존재, 2번은 1명 존재, 3번은 1명 존재,
        4번은 0명 존재
        그러면 4번이 제일 크고, 2번이 제일 큰 4번만 존재, 1번은 제일큰 4번과 2번존재
        그다음은 3번
        그러면 일단 주어진 순서대로 배열에 넣는다.
        배열에 넣고 퀵 정렬 해볼까
        인접한 배열의 원소가
        배열에 왼쪽에 있는 자기보다 큰 사람의 수를 입력 받는다.
        그럼 배열에는 5,4,3,2,1,0 이렇게 입력되었을 때
        큌 정렬을 이용하면 되지 않을까? 라느 생각이 든다.
        첫번째 원소의 값이 왼쪾에 2명이 있다는 뜻이면 2칸을 오른쪽으로 이동한다.
        즉 세번째원소와 첫번째 원소와 바꾼다.
        그러면 1 1 2 0이 된다.
        첫번째 원소로 와버린 1은 왼쪽에 큰 사람이 한명 있어야 되는데 없기때문에 바꿔줘야 한다(swqp함수 이용하자)
        이때 무슨 원소랑 바꿔야할까? 두번째 원소는 1이다. 두번째원소랑 바꿀경우, 똑같이 왼쪽에 1명이 있어야 되는데 없음으로 불가능하다.
        그러면 세번쨰 원소인 1번이랑 바꿔야할까? 이 경우에도 불가능하다.
        그러면 왼쪽에 큰 사람이 0 인 4번쨰 원소가 와야 한다.
        그러면 3번과 4번을 바꾼다.
        배열에서 자신의 왼쪽에서 자기보다 큰 최댓값의 갯수를 찾는 것과 같다.
        만약 2,1,1,0일때
        첫번쨰 배열의 원소는 제일 최댓값이여야 하고, 그 다음으로 오는 두번째 원소는 왼쪽에 최댓값이 존재하니깐 최댓값 개수가 1인 원소가 와야한다.
        세번쨰 원소는 최댓값의 갯수가 2인 원소가 와야한다.
        정렬로 해야되나? -> 정렬로도 해보자
        백트래킹은 아닌것같고..그리디 알고리즘으로 해볼까?
        -- 그리디 알고리즘으로 설계 해보기--
        최선의 결정을 하기 위해 그리디 초이스를 한다.
        모든 경우를 보지않고 근시안적인 최선의 선택을 한다.
        아뭐여 그리디 알고리즘에서 테이프 파일 저장한 알고리즘이랑 비슷한 원리인것같다.
        저장을 해놓고 나면, 자신을 읽기 위해서는 내앞에 있는 것까지의 시간이 추가로 걸린다.
        --> 저장하는 파일의 순서를 잘 조절하면 걸리는 시간을 줄일 수 있을 것이다.
        ㅠ(i)를 i번째 위치에 둘 파일의 번호라고하자
       파이가 곧 순서이다.에
       파이 함수를 내가 어떻게 설정하느냐에 따라 cost가 달라진다.
       그니깐
       그니깐 배열의 원소에서 자기보다 왼쪽에 있는 사람의 수를 나타낸거를 cost라고 생각하면
       이해가 될것이다.
       앞에있는 파일을 읽으려고할때마다 1번위치의 파일을 흝고 지나갈수 밖에 없다.
       그러면 앞에 있는 파일은 길이가 짦은 놈으로 두면 된다.
       그니깐 여기서는 자기보다 왼쪽에 큰사람이 있는 수가 적은 놈으로 두면 된다.
       그니깐 매번 지나가야되면 이왕 큰 사람을 앞에다가 위치해두는게 낫다.
       그럼 큰 사람이 앞으로 오고,작은 사람이 뒤로 가는, 길이가 증가하는 순서대로 놓으면 된다.
       그럼 아시발 그럼 테이프의 길이로 생각해보면 간단하구나
       길이 순으로 file을 정렬 후에 그 순서로 테이프에 저장한다.
       길이를 순서대로 정렬했을 때, cost[ㅠ]의 기댓값이 치ㅗ소화된다.

         */

        Scanner sc=new Scanner(System.in);
        ArrayList<Integer>list=new ArrayList<>();
        int n;
        n=sc.nextInt();
        int a[]=new int[n+1];//1부터 시작
        for(int i=1;i<=n;i++){
            a[i]=sc.nextInt();
        }
        for(int i=n;i>=1;i--){
            list.add(a[i],i);
        }
        for(int k:list){
            System.out.println(k);
        }


    }
    }
